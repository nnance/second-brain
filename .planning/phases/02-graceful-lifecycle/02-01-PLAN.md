---
phase: 02-graceful-lifecycle
plan: 01
type: execute
depends_on: []
files_modified: [src/index.ts, src/sessions/store.ts]
---

<objective>
Add session restoration on application startup.

Purpose: Sessions persisted to disk in Phase 1 must be loaded before the listener starts accepting messages.
Output: initSessionStore() called at startup, sessions restored from .sessions.json before processing messages.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-session-persistence/01-01-SUMMARY.md
@src/index.ts
@src/sessions/store.ts
@src/sessions/file-store.ts

**Tech stack:** Node.js 20+, TypeScript, ES modules
**Established patterns:**
- Fire-and-forget async saves (from Phase 1)
- Pino structured logging
- kebab-case file names, camelCase functions
- `.js` extension on relative imports

**Key insight from Phase 1:**
- initSessionStore() exists but is NOT called at startup
- This must be fixed for persistence to work
</context>

<tasks>

<task type="auto">
  <name>Task 1: Call initSessionStore on startup</name>
  <files>src/index.ts</files>
  <action>
Modify src/index.ts to initialize the session store before starting the listener:

1. Import `initSessionStore` from `./sessions/store.js`
2. Create an async `main()` function that:
   - Calls `await initSessionStore()` first
   - Then calls `startListener(...)`
   - Then calls `startTimeoutChecker()`
3. Call `main()` and handle errors with process.exit(1)

This ensures sessions are loaded from disk before we start accepting messages.

Example structure:
```typescript
async function main() {
  logger.info({ vaultPath: config.vaultPath, model: config.claudeModel }, "second-brain starting...");

  // Load persisted sessions from disk
  await initSessionStore();

  // Start message listener
  await startListener({ onMessage: async (message) => { ... } });

  // Start timeout checker
  startTimeoutChecker();

  logger.info("Listening for messages...");
}

main().catch((error) => {
  logger.error({ error }, "Failed to start");
  process.exit(1);
});
```
  </action>
  <verify>
1. `npm run build` passes
2. Code review: initSessionStore() called before startListener()
  </verify>
  <done>
- initSessionStore imported and called at startup
- Startup sequence: init sessions → start listener → start timeout checker
- Build passes
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds
- [ ] `npm run lint` passes
- [ ] initSessionStore() is called before startListener()
</verification>

<success_criteria>
- initSessionStore() called at application startup
- Sessions loaded from disk before listener starts
- Build passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-graceful-lifecycle/02-01-SUMMARY.md`
</output>
