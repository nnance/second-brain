---
phase: 01-session-persistence
plan: 01
type: execute
depends_on: []
files_modified: [src/sessions/file-store.ts, src/sessions/store.ts, src/config.ts]
---

<objective>
Implement file-based session storage and migrate the existing in-memory store to use it.

Purpose: Sessions must survive process restarts. The current Map-based store loses all state when the process terminates.
Output: A file-backed session store that persists sessions to disk on every write and loads them on startup.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/sessions/store.ts
@src/config.ts

**Tech stack:** Node.js 20+, TypeScript, ES modules
**Established patterns:**
- Result objects with `success` boolean for operations that can fail
- Pino structured logging
- kebab-case file names, camelCase functions
- `.js` extension on relative imports
- Error handling: try-catch at boundaries, log with context

**Constraining decisions:**
- File persistence over SQLite (minimal dependencies)
- No new dependencies if possible
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create file store module</name>
  <files>src/sessions/file-store.ts</files>
  <action>
Create a new module that handles file-based session persistence:

1. Add `SESSION_STORE_PATH` to config.ts (default: `${process.cwd()}/.sessions.json`)
2. Create `src/sessions/file-store.ts` with:
   - `loadSessions(): Promise<Map<string, Session>>` — read JSON file, parse, return Map. If file doesn't exist, return empty Map.
   - `saveSessions(sessions: Map<string, Session>): Promise<void>` — serialize Map to JSON, write atomically (write to temp file, rename).
   - Handle Date serialization: `lastActivity` stored as ISO string, parsed back to Date on load.

Use atomic writes (write to `.sessions.json.tmp`, then rename to `.sessions.json`) to prevent corruption on crash.

Import Session interface from `./store.js`.

Follow project patterns:
- Result objects not needed here (throw on critical errors, caller handles)
- Use `node:fs/promises` for file operations
- Log file operations with Pino logger
  </action>
  <verify>TypeScript compiles: `npm run build` passes. File can be imported.</verify>
  <done>file-store.ts exists with loadSessions() and saveSessions() functions, builds without errors</done>
</task>

<task type="auto">
  <name>Task 2: Migrate store.ts to use file backend</name>
  <files>src/sessions/store.ts</files>
  <action>
Modify store.ts to persist to disk:

1. Keep the in-memory Map as the primary data structure (fast reads)
2. Add `initSessionStore(): Promise<void>` — call loadSessions(), populate the Map
3. Modify `createSession()`, `updateSession()`, `deleteSession()` to call `saveSessions()` after mutating the Map
4. Keep `getSession()`, `getAllSessions()`, `getOrCreateSession()` as sync reads from Map
5. Keep `clearAllSessions()` for testing (also saves empty state to file)

The save operations are async but we fire-and-forget (don't await in the CRUD functions). The Map is authoritative during runtime; file is for persistence across restarts.

Note: For write operations, save asynchronously without blocking the return. Log any save errors but don't fail the operation.

Example pattern:
```typescript
export function createSession(senderId: string): Session {
  const session: Session = { senderId, lastActivity: new Date() };
  sessions.set(senderId, session);
  // Fire and forget - don't await
  saveSessions(sessions).catch(err => logger.error({ err }, "Failed to persist session"));
  return session;
}
```
  </action>
  <verify>
1. `npm run build` passes
2. `npm test` passes (existing tests still work)
3. Manual verification: Run `npm run dev`, create session via code, check `.sessions.json` file appears
  </verify>
  <done>
- store.ts exports initSessionStore()
- CRUD operations persist to file
- Existing tests pass
- .sessions.json file created when sessions exist
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm test` passes all existing tests
- [ ] `npm run lint` passes
- [ ] `.sessions.json` file created when sessions are created
- [ ] File contains valid JSON with session data
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors
- Existing session tests still pass
- File persistence works (sessions survive between imports in REPL)
</success_criteria>

<output>
After completion, create `.planning/phases/01-session-persistence/01-01-SUMMARY.md`
</output>
